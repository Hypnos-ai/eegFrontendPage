<!DOCTYPE html>
<html>

<head>
    <title>EEG Research Interface</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
        }

        .control-panel {
            border: 1px solid #ccc;
            padding: 20px;
        }

        .visualization {
            border: 1px solid #ccc;
            padding: 20px;
        }

        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .success {
            background-color: #dff0d8;
            color: #3c763d;
        }

        .error {
            background-color: #f2dede;
            color: #a94442;
        }

        .recording {
            background-color: #f8d7da;
            animation: blink 1s infinite;
            font-weight: bold;
        }

        @keyframes blink {
            50% {
                opacity: 0.5;
            }
        }

        #statusMessages {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
        }

        .recording-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px;
            background-color: red;
            color: white;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        .feature-plot {
            margin-top: 20px;
            height: 300px;
        }

        .button-group {
            margin: 10px 0;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        button:hover:not(:disabled) {
            background-color: #0056b3;
        }

        .timer {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
        }

        .signal-good {
            color: #28a745;
        }

        .signal-bad {
            color: #dc3545;
        }

        #signalQuality {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        #eegPlot {
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            background: white;
        }

        .task-display {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        #taskName {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #taskInstruction {
            font-style: italic;
            margin-bottom: 10px;
        }

        #taskProgress {
            font-size: 0.9em;
            color: #666;
        }

        #stopSessionButton {
            background-color: #dc3545;  /* Red color for stop button */
        }

        #stopSessionButton:hover:not(:disabled) {
            background-color: #c82333;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="control-panel">
            <h2>Control Panel</h2>
            <div id="connectionStatus" class="status">Not connected</div>

            <div class="button-group">
                <input type="number" id="sessionNum" value="1" min="1" style="width: 60px;"> session number
                <input type="number" id="samplesPerAction" value="21" min="1" style="width: 60px;"> samples per action
                <input type="number" id="breakDuration" value="3" min="1" style="width: 60px;"> break duration (s)
                <button onclick="startSession()" id="sessionButton">Start Session</button>
                <button onclick="stopSession()" id="stopSessionButton" disabled>Stop Session</button>
            </div>

            <div id="taskDisplay" class="task-display" style="display: none;">
                <h3>Current Task</h3>
                <div id="taskName"></div>
                <div id="taskInstruction"></div>
                <div id="taskProgress"></div>
            </div>

            <div class="button-group">
                <input type="number" id="duration" value="5" min="1" style="width: 60px;"> seconds
                <button onclick="startRecording()" id="startButton" disabled>Start Recording</button>
                <button onclick="stopRecording()" id="stopButton" disabled>Stop Recording</button>
            </div>

            <div id="timer" class="timer"></div>

            <div class="button-group">
                <button onclick="trainModel()" id="trainButton">Train Model</button>
                <button onclick="analyzeSession()" id="analyzeButton">Analyze Session</button>
                <span id="trainingStatus"></span>
            </div>

            <div id="statusMessages"></div>
        </div>

        <div class="visualization">
            <h2>EEG Visualization</h2>
            <div id="eegPlot"></div>
            <div id="featurePlot" class="feature-plot"></div>
        </div>

        <div class="visualization">
            <h2>CSP Analysis</h2>
            <div id="cspPlots"></div>
            <div id="classStats"></div>
        </div>
    </div>

    <script>
        const socket = io();
        let isRecording = false;
        let recordingStartTime = null;
        let recordingTimer = null;

        // Initialize plot data for 6 EEG channels
        let plotData = Array(6).fill().map((_, i) => ({
            y: [],
            name: ['FCz', 'C3', 'Cz', 'CPz', 'C2', 'C4'][i],
            type: 'scatter',
            mode: 'lines',
            line: { 
                width: 1, 
                color: getChannelColor(i),
                shape: 'spline'  // Use spline for smoother lines
            }
        }));

        // Add color function for channels
        function getChannelColor(index) {
            const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'];
            return colors[index % colors.length];
        }

        // Initialize the plot with proper EEG settings
        const layout = {
            title: {
                text: 'Real-time EEG Data',
                font: { size: 24 }
            },
            xaxis: {
                title: 'Time (samples)',
                range: [0, 250],  // Show 1 second of data
                showgrid: true,
                gridcolor: '#e1e1e1'
            },
            yaxis: {
                title: 'Amplitude (μV)',
                range: [-50, 50],  // More typical EEG range
                zeroline: true,
                zerolinecolor: '#969696',
                gridcolor: '#bdbdbd',
                gridwidth: 1
            },
            height: 600,
            margin: { l: 50, r: 50, t: 50, b: 50 },
            showlegend: true,
            legend: {
                x: 1,
                xanchor: 'right',
                y: 1
            },
            paper_bgcolor: 'white',
            plot_bgcolor: '#f8f9fa',
            uirevision: true,  // Keep zoom/pan state
            animation: {
                duration: 0  // Faster updates
            }
        };

        // Create plot with config
        Plotly.newPlot('eegPlot', plotData, layout, {
            responsive: true,
            scrollZoom: true,
            displayModeBar: true,
            displaylogo: false,
            modeBarButtonsToRemove: ['autoScale2d', 'lasso2d', 'select2d'],
            showTips: true
        });

        // Socket event handler for EEG data
        socket.on('eeg_data', function (data) {
            if (data && data.data) {
                console.log("Raw data received:", data.data);  // Debug log
                const maxPoints = 500;  // 2 seconds at 250Hz
                // Update each channel's data
                for (let i = 0; i < 6; i++) {
                    if (!Array.isArray(data.data[i])) continue;
                    // Maintain a moving window of 2 seconds (500 samples)
                    if (plotData[i].y.length > maxPoints) {
                        plotData[i].y = plotData[i].y.slice(-maxPoints);
                    }
                    // Add new data
                    plotData[i].y = plotData[i].y.concat(data.data[i]);
                }

                // Update x-axis range to show moving window
                const xrange = [Math.max(0, plotData[0].y.length - 250),
                               plotData[0].y.length];

                // Update plot with new data and layout
                try {
                    Plotly.animate('eegPlot', {
                        data: plotData,
                        layout: {
                            xaxis: { range: xrange }
                        }
                    }, {
                        transition: {
                            duration: 0
                        },
                        frame: {
                            duration: 0,
                            redraw: false
                        }
                    });
                    console.log("Plot updated successfully");  // Debug log
                } catch (error) {
                    console.error("Error updating plot:", error);
                }
                
                // Update signal quality indicators
                updateSignalQuality(data.data);

                // Update recording status if needed
                if (data.is_recording) {
                    document.getElementById('connectionStatus').classList.add('recording');
                }
            }
        });

        // Add status indicator for signal quality
        function updateSignalQuality(data) {
            const qualities = data.map(channel =>
                Math.abs(channel.reduce((a, b) => a + b, 0) / channel.length)
            );

            const qualityDiv = document.getElementById('signalQuality');
            qualityDiv.innerHTML = qualities.map((q, i) =>
                `Channel ${plotData[i].name}: ${q < 100 ? '✓' : '⚠️'}`
            ).join('<br>');
        }

        // Add this function before the initializeBoard function
        function addStatusMessage(message) {
            const statusDiv = document.getElementById('statusMessages');
            const timestamp = new Date().toLocaleTimeString();
            const messageElement = document.createElement('div');
            messageElement.textContent = `[${timestamp}] ${message}`;
            statusDiv.insertBefore(messageElement, statusDiv.firstChild);
            
            // Keep only last 50 messages
            while (statusDiv.children.length > 50) {
                statusDiv.removeChild(statusDiv.lastChild);
            }
        }

        // Add socket listener for board status
        socket.on('board_status', function (data) {
            console.log('Board status:', data);
            if (data.status === 'success') {
                document.getElementById('connectionStatus').textContent = 'Connected';
                document.getElementById('connectionStatus').className = 'status success';
                document.getElementById('startButton').disabled = false;
            } else {
                document.getElementById('connectionStatus').textContent = 'Error: ' + data.message;
                document.getElementById('connectionStatus').className = 'status error';
            }
        });

        // Add this after socket initialization
        socket.on('connect', function() {
            console.log('Connected to server');
            addStatusMessage('Connected to server');
        });

        socket.on('disconnect', function() {
            console.log('Disconnected from server');
            addStatusMessage('Disconnected from server');
            document.getElementById('connectionStatus').textContent = 'Server disconnected';
            document.getElementById('connectionStatus').className = 'status error';
            document.getElementById('startButton').disabled = true;
        });

        socket.on('error', function(error) {
            console.error('Socket error:', error);
            addStatusMessage('Socket error: ' + error.message);
        });

        // Add these variables at the top of your script
        let currentTaskIndex = 0;
        let totalTasks = 0;
        let isSessionActive = false;
        let currentBreakDuration = 3; // Default break duration

        function startSession() {
            const sessionNum = document.getElementById('sessionNum').value;
            const samplesPerAction = document.getElementById('samplesPerAction').value;
            const breakDuration = document.getElementById('breakDuration').value;
            currentBreakDuration = parseInt(breakDuration); // Store break duration
            document.getElementById('sessionButton').disabled = true;
            
            // First initialize board
            document.getElementById('connectionStatus').textContent = 'Initializing board...';
            
            fetch('/initialize', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({})
            })
            .then(response => response.json())
            .then(data => {
                if (data.status !== 'success') {
                    throw new Error(data.message || 'Failed to initialize board');
                }
                
                // After board is initialized, start session
                return fetch('/start_session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({ 
                        session_num: parseInt(sessionNum),
                        samples_per_action: parseInt(samplesPerAction),
                        break_duration: parseInt(breakDuration)
                    })
                });
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    totalTasks = data.total_tasks;
                    isSessionActive = true;
                    document.getElementById('taskDisplay').style.display = 'block';
                    document.getElementById('stopSessionButton').disabled = false;
                    if (data.session_num !== parseInt(sessionNum)) {
                        document.getElementById('sessionNum').value = data.session_num;
                        addStatusMessage(`Session number auto-assigned to ${data.session_num}`);
                    }
                    addStatusMessage(`Session ${data.session_num} started. Total tasks: ${totalTasks}`);
                    getNextTask();
                } else {
                    throw new Error(data.message || 'Failed to start session');
                }
            })
            .catch(error => {
                document.getElementById('sessionButton').disabled = false;
                document.getElementById('connectionStatus').textContent = 'Error: ' + error.message;
                document.getElementById('connectionStatus').className = 'status error';
                addStatusMessage('Session error: ' + error.message);
            });
        }

        function getNextTask() {
            if (!isSessionActive) return;
            
            fetch('/next_task')
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    currentTaskIndex++;
                    displayTask(data);
                    startTaskRecording(data);
                } else if (data.status === 'complete') {
                    completeSession();
                } else {
                    throw new Error(data.message || 'Failed to get next task');
                }
            })
            .catch(error => {
                addStatusMessage('Task error: ' + error.message);
            });
        }

        function displayTask(taskData) {
            document.getElementById('taskName').textContent = taskData.task_name;
            document.getElementById('taskInstruction').textContent = taskData.instruction;
            document.getElementById('taskProgress').textContent = 
                `Task ${currentTaskIndex} of ${totalTasks}`;
        }

        function startTaskRecording(taskData) {
            // Start recording immediately when task is shown
            document.getElementById('duration').value = taskData.duration;
            startRecording(taskData.task_name);
        }

        function completeSession() {
            isSessionActive = false;
            document.getElementById('taskDisplay').style.display = 'none';
            document.getElementById('sessionButton').disabled = false;
            addStatusMessage('Session completed, processing files...');
            
            fetch('/complete_session', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    addStatusMessage('Session data processed successfully');
                } else {
                    throw new Error(data.message || 'Failed to process session data');
                }
            })
            .catch(error => {
                addStatusMessage('Error processing session: ' + error.message);
            });
        }

        // Modify the existing startRecording function
        function startRecording(task_name) {
            const duration = document.getElementById('duration').value;
            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = false;
            
            fetch('/start_recording', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({ 
                    duration: parseInt(duration),
                    task_name: task_name
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    addStatusMessage('Recording started');
                    document.getElementById('connectionStatus').classList.add('recording');
                    startTimer(duration);
                } else {
                    throw new Error(data.message || 'Failed to start recording');
                }
            })
            .catch(error => {
                const errorMessage = error.message || 'Error starting recording';
                addStatusMessage('Recording error: ' + errorMessage);
                document.getElementById('startButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
            });
        }

        // Modify the existing stopRecording function
        function stopRecording() {
            document.getElementById('stopButton').disabled = true;
            
            fetch('/stop_recording', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    addStatusMessage('Recording stopped');
                    document.getElementById('connectionStatus').classList.remove('recording');
                    document.getElementById('startButton').disabled = false;
                    stopTimer();
                    
                    // If in a session, start break countdown immediately
                    if (isSessionActive) {
                        startBreakCountdown();
                    }
                } else {
                    throw new Error(data.message || 'Failed to stop recording');
                }
            })
            .catch(error => {
                const errorMessage = error.message || 'Error stopping recording';
                addStatusMessage('Recording error: ' + errorMessage);
                document.getElementById('stopButton').disabled = false;
            });
        }

        // Add timer functionality
        let timerInterval = null;

        function startTimer(duration) {
            const timerDisplay = document.getElementById('timer');
            let timeLeft = duration;
            
            timerDisplay.textContent = `${timeLeft}s`;
            
            timerInterval = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = `${timeLeft}s`;
                
                if (timeLeft <= 0) {
                    stopRecording();
                    stopTimer();
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            document.getElementById('timer').textContent = '';
        }

        // Add socket listener for recording status
        socket.on('recording_status', function(data) {
            console.log('Recording status:', data);
            if (data.status === 'started') {
                document.getElementById('connectionStatus').classList.add('recording');
                document.getElementById('startButton').disabled = true;
                document.getElementById('stopButton').disabled = false;
            } else if (data.status === 'stopped') {
                document.getElementById('connectionStatus').classList.remove('recording');
                document.getElementById('startButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
                stopTimer();
            }
        });

        function stopSession() {
            isSessionActive = false;
            document.getElementById('stopSessionButton').disabled = true;
            document.getElementById('sessionButton').disabled = false;
            document.getElementById('taskDisplay').style.display = 'none';
            
            // Stop any ongoing recording
            if (document.getElementById('stopButton').disabled === false) {
                stopRecording();
            }
            
            addStatusMessage('Session stopped by user');
            
            // Write session end marker to annotations
            fetch('/stop_session', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    addStatusMessage('Session data saved');
                } else {
                    throw new Error(data.message || 'Failed to save session');
                }
            })
            .catch(error => {
                addStatusMessage('Error saving session: ' + error.message);
            });
        }

        function startBreakCountdown() {
            let countdown = currentBreakDuration;
            document.getElementById('timer').textContent = `Break: ${countdown}s`;
            
            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    document.getElementById('timer').textContent = `Break: ${countdown}s`;
                } else {
                    clearInterval(countdownInterval);
                    getNextTask();
                }
            }, 1000);
        }

        function analyzeSession() {
            fetch('/analyze_session', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Create plots for each class
                    const plotDiv = document.getElementById('cspPlots');
                    plotDiv.innerHTML = '';
                    
                    // Create a grid of plots
                    data.class_names.forEach((className, classIdx) => {
                        const classDiv = document.createElement('div');
                        classDiv.style.marginBottom = '20px';
                        
                        const title = document.createElement('h3');
                        title.textContent = className;
                        classDiv.appendChild(title);
                        
                        // Create plots for top 3 components
                        const patterns = data.csp_patterns[classIdx];
                        patterns.forEach((pattern, compIdx) => {
                            // Create topomap data
                            const plotData = [{
                                type: 'scatter',
                                mode: 'markers+lines',
                                x: Array.from({length: 6}, (_, i) => i),  // Channel positions
                                y: pattern,
                                name: `Component ${compIdx + 1}`,
                                line: {
                                    color: getChannelColor(compIdx),
                                    width: 2
                                },
                                marker: {
                                    size: 8,
                                    color: getChannelColor(compIdx)
                                }
                            }];
                            
                            const plotTitle = `Component ${compIdx + 1}`;
                            const plotLayout = {
                                title: plotTitle,
                                height: 300,
                                width: 300,
                                xaxis: {
                                    title: 'Channel',
                                    ticktext: data.channel_names,
                                    tickvals: Array.from({length: 6}, (_, i) => i),
                                    showgrid: true
                                },
                                yaxis: {
                                    title: 'Pattern Weight',
                                    range: [-4, 4],  // Typical range for CSP patterns
                                    showgrid: true
                                }
                            };
                            
                            const plotContainer = document.createElement('div');
                            plotContainer.style.display = 'inline-block';
                            classDiv.appendChild(plotContainer);
                            
                            Plotly.newPlot(plotContainer, plotData, plotLayout);
                        });
                        
                        plotDiv.appendChild(classDiv);
                    });
                    
                    // Show class statistics
                    const statsDiv = document.getElementById('classStats');
                    statsDiv.innerHTML = '<h3>Trial Counts</h3>';
                    data.class_names.forEach((className, idx) => {
                        statsDiv.innerHTML += `<p>${className}: ${data.class_counts[idx]} trials</p>`;
                    });
                    
                    addStatusMessage('Analysis completed successfully');
                } else {
                    addStatusMessage('Analysis error: ' + data.message);
                }
            })
            .catch(error => {
                addStatusMessage('Analysis error: ' + error.message);
            });
        }
    </script>

    <!-- Add signal quality indicator to HTML -->
    <div id="signalQuality" class="status"></div>
</body>

</html>